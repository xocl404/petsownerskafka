# pets and owners
В рамках данного проекта последовательно выполнены перечисленные ниже работы, в коде представлен финальный проект

# Отрабатываемый материал

Изучение языка Java, инстументов сборки и встроенных инструментов для работы с персистентными хранилищами.

# Цель

Изучение архитектурного подхода Сontroller-Service-Dao.
Получение прикладных навыков работы с JDBC (Java DataBase Connectivity).  

# Задание

Реализовать приложение для работы с базой данных через ORM.
Необходимо создать модели для описание таблиц баз данных согласно конвенциям JPA.

Дополнительно:
 Предусмотреть возможность применения миграций базы данных.

# Функциональные требования

Описать следующие сущности:

- Питомец
  
Имя  
Дата рождения  
Порода  
Цвет (один из заранее заданных вариантов)  
Хозяин  
Список котиков, с которыми дружит этот котик (из представленных в базе)  

- Хозяин (владелец питомца):
  
Имя  
Дата рождения  
Список котиков   

- Реализовать CRUD (create, read, update, delete) операции для описанных вами сущностей. 
```java
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

# Не функциональные требования

В качестве базы данных рекомендуется использовать PostgreSQL.  
Для связи с БД рекомендуется использоваться Hibernate.

- Лабораторная работа должна быть выполнена как отдельный модуль/проект.
- Рекомендуется использование JDBC-совместимых конфигураций ORM. 
- Использование Spring Framework и Spring Boot - запрещено.  
- Сторонние зависимости должны поставляться системой сборки автоматически.

# Отрабатываемый материал

Изучение фреймворка Spring и дополнений к нему в виде Spring Data JPA, Spring Boot.

# Цель

Получение прикладных навыков работы c фреймворком Spring.

# Задание

Реализовать веб-приложение на основе шаблона Spring MVC с использованием Spring Boot для работы с имеющейся базой данных через Spring Data JPA.  
Приложение должно предоставлять HTTP интерфейс (REST API) для получения информации о конкретных котиках и их владельцах.  

Дополнительно:  
 Если вами были предусмотрены миграции в предыдущей лабораторной - необходимо добавить новый аттрибут вашей сущности (например - длина хвоста котика)  
 Наличие [swagger](https://springdoc.org/#getting-started) спецификации.

# Функциональные требования

- Слой представления не должен отдавать через HTTP интерфейс сущности JPA. Необходимо использование Data Transfer Object'ов.
- Реализовать возможность пагинации и фильтрации результатов поисковых запросов (т.е. Первые пять рыжих котов, и т.д.)
- В качестве репозиториев должны использоваться реализации унаследованные от CrudRepository (и прочих производных)

# Не функциональные требования

- Лабораторная работа должна быть выполнена как отдельный модуль/проект.
- В качестве ORM необходимо использовать Spring Data JPA
- Все классы должны получать свои зависимости с использованием Dependency Injection на основе JavaBeans.
- Сторонние зависимости должны поставляться системой сборки автоматически.


# Отрабатываемый материал

Изучение фреймворка Spring и дополнений к нему в виде Spring Security.

# Цель

Получение прикладных навыков работы c Spring Security, понимания встроенных схем аутентификации и авторизации.

# Задание

Дополнить полученное в рамках третьей лабораторной работы веб-приложение и реализовать ролевую модель для взаимодействия с имеющимися сущностями.      
В качестве используемых ролей необходимо реализовать администратора и пользователя (субъектом аутентификации является владелец котика).  

Дополнительно:  
 Если вами было предусмотрено наличие [swagger](https://springdoc.org/#getting-started) спецификации, необходимо расширить её и добавить разделение по ролям на существующие endpoint'ы.  
 Так же должна быть реализована возможность получения пользовательской сессии непосредственно через Swagger UI.   
 Так же, **при наличии миграций, необходимо добавить создание учётной записи администратора с паролем по-умолчанию.**

Дополнительно со звёздочкой:
 В качестве схемы аутентификации можно использовать JWT, в таком случае подразумевается отключение встроенного Session managment'a и замещение информации о субъекте аутентификации данными из Claim'ов токена.   

# Функциональные требования

- Необходимо реализовать сущность пользователь и соотвествующие Endpoint'ы для получения пользовательских сессий.
- Неаутентифицированные запросы должны быть отклонены с ответом HTTP 401 Not Authorized
- Доступ к методам для изменения информации имеют только владельцы котиков и администраторы.
- Доступ к методам для получения информации о котиках должны иметь все авторизованные пользователи.
- В случаях когда владелец котика пытается изменить информацию о чужом питомце необходимо пресекать такие запросы с ответом HTTP 403 Forbidden.  

# Не функциональные требования

- Endpoint'ы приложения должны быть защищены Spring Security **версии 6.x.x**
- Запрещено использование старых подходов основанных на WebSecurity*Adapter
- Конфигурация Spring Security должна быть описана на основе [SecurityFilterChain](https://docs.spring.io/spring-security/reference/servlet/architecture.html)
- Пароли пользователей должны храниться в зашифрованном виде
- Реализация имеющихся контроллеров не должна меняться. Добавление новых аннотаций - разрешено.
- Разрешается отключение встроенных механизмов безопасности как CSRF и CORS.
 
# Отрабатываемый материал

Изучение микросервисной архитектуры и способов интеграции через Java Messaging Service.

# Цель

Получение прикладных навыков работы c Spring AQMP, JMS, брокеров сообщений и способов обеспечения микросервисного взаимодействия.

# Задание

В рамках лабораторной работы необходимо реализовать *три отдельных* Java приложения.
 - Микросервис работы с питомцами
 - Микросервис работы с владельцами
 - HTTP Web-gateway для обработки запросов

Для каждого приложения подразумевается отдельная база данных. Web-Gateway хранит информацию исключительно о пользователях (+ роли и пароли).  
Микросервис питомцев ничего не знает о их владельцев, кроме внешнего идентификатора.  
Микросервис владельцев соотвественно ничего не знает о том какие питомцы есть у человека.
 
Полученное в рамках предыдущей лабораторной работы веб-приложение необходимо отвязать от бизнес логики работы с владельцами и их питомцами и вынести в отдельный модуль. 
Данное приложение должно принимать запросы с помощью Spring Web и общаясь через брокера сообщений транслировать ответы от микросервисов в те же модели ответов, которые были получены в рамках третьей лабораторной работы.  
т.е. для конечного пользователя контракт взаимодействия с вашим сервисом не должен изменится.

Общение между микросервисами происходит через брокера сообщений RabbitMQ / Kafka (на выбор студента).  
В качестве шаблона для общения рекомендуется использование платформозависимых реализаций KafkaTemplate либо RabbitTemplate соотвественно.  
